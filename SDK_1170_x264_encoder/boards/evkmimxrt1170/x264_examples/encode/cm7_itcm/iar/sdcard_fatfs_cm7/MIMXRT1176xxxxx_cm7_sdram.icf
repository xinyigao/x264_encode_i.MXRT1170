/*
** ###################################################################
**     Processors:          MIMXRT1176AVM8A_cm7
**                          MIMXRT1176CVM8A_cm7
**                          MIMXRT1176DVMAA_cm7
**
**     Compiler:            IAR ANSI C/C++ Compiler for ARM
**     Reference manual:    IMXRT1170RM_initial_draft, 02/2018
**     Version:             rev. 0.1, 2018-03-05
**     Build:               b190819
**
**     Abstract:
**         Linker file for the IAR ANSI C/C++ Compiler for ARM
**
**     Copyright 2016 Freescale Semiconductor, Inc.
**     Copyright 2016-2019 NXP
**     All rights reserved.
**
**     SPDX-License-Identifier: BSD-3-Clause
**
**     http:                 www.nxp.com
**     mail:                 support@nxp.com
**
** ###################################################################
*/

define symbol m_interrupts_start       = 0x80002000;
define symbol m_interrupts_end         = 0x800023FF;

define symbol m_text_start             = 0x80002400;
define symbol m_text_end               = 0x801FFFFF;

define symbol m_data_start             = 0x80200000;
define symbol m_data_end               = 0x82FFFFFF;

define symbol m_ncache_start           = 0x83000000;
define symbol m_ncache_end             = 0x83FFFFFF;

define symbol m_itcm_start	= 0;
define symbol m_itcm_end	= 0x3FFFF;

//define symbol m_dtcm_start  = 0x20000000;
//define symbol m_dtcm_end = 0x2001FFFF;
/* Sizes */
if (isdefinedsymbol(__stack_size__)) {
  define symbol __size_cstack__        = __stack_size__;
} else {
  define symbol __size_cstack__        = 0x300000;
}

if (isdefinedsymbol(__heap_size__)) {
  define symbol __size_heap__          = __heap_size__;
} else {
  define symbol __size_heap__          = 0x1000000;
}

define exported symbol __NCACHE_REGION_START   = m_ncache_start;
define exported symbol __NCACHE_REGION_SIZE    = m_ncache_end - m_ncache_start + 1;

define exported symbol __VECTOR_TABLE  = m_interrupts_start;
define exported symbol __VECTOR_RAM    = m_interrupts_start;
define exported symbol __RAM_VECTOR_TABLE_SIZE = 0x0;

define memory mem with size = 4G;
define region TEXT_region   = mem:[from m_interrupts_start to m_interrupts_end]
                            | mem:[from m_text_start to m_text_end];
                            
//define region DTCM_region = mem:[from m_dtcm_start to m_dtcm_end];
define region ITCM_region = mem:[from m_itcm_start to m_itcm_end];                            
define region DATA_region   = mem:[from m_data_start to m_data_end-__size_heap__];
define region HEAP_region   = mem:[from m_data_end-__size_heap__+1 to m_data_end];
define region NCACHE_region = mem:[from m_ncache_start to m_ncache_end];

define block CSTACK    with alignment = 8, size = __size_cstack__   { };
define block HEAP      with alignment = 8, size = __size_heap__     { };
define block RW        { first readwrite, section m_usb_dma_init_data };
define block ZI         with alignment = 32  { first zi, section m_usb_dma_noninit_data };
define block NCACHE_VAR with size = 0x01000000 , alignment = 0x100000  { section NonCacheable , section NonCacheable.init };

initialize by copy { readwrite, section .textrw };
do not initialize  { section .noinit };

place at address mem: m_interrupts_start    { readonly section .intvec };

place in TEXT_region                        { readonly };
place in DATA_region                        { block RW };
place in DATA_region                        { block ZI };
place in DATA_region                        { block CSTACK };
place in HEAP_region                        { last block HEAP };
place in NCACHE_region                      { block NCACHE_VAR };
place in ITCM_region {rw section .critical_text};
initialize manually {section .critical_text};

place in ITCM_region {rw object frame.o,rw object bitstream.o, rw object macroblock_encoder.o, rw object dct.o, rw object deblock.o, rw object macroblock.o, rw object mc.o, rw object mvpred.o, rw object osdep.o,rw object pixel.o,rw object predict.o,rw object quant.o, rw object ratecontrol.o, rw object me.o, rw object cabac_encoder.o, rw object encoder.o};
initialize by copy {object frame.o, object bitstream.o,object macroblock_encoder.o, object dct.o, object deblock.o, object macroblock.o, object mc.o, object mvpred.o, object osdep.o, object pixel.o, object predict.o, object quant.o,object ratecontrol.o,object me.o,object cabac_encoder.o,object encoder.o};
// object cabac.o,
//////place in DTCM_region                      { block CSTACK };
//place in DTCM_region {rw object h264data.o, rw section .fast_data};